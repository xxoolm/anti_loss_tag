

## 一、UUID 总表 

| UUID                                   | 类型                               | 作用（在你工程里的含义）                                        | 典型数据                                      | 何时用               |
| -------------------------------------- | -------------------------------- | --------------------------------------------------- | ----------------------------------------- | ----------------- |
| `0000FFE0-0000-1000-8000-00805F9B34FB` | 自定义 Service（厂商私有）                | **扫描过滤用的服务 UUID**：只扫描“广播里声明了该服务”的设备                 | 无（扫描过滤不读写数据）                              | 扫描阶段              |
| `0000FFE1-0000-1000-8000-00805F9B34FB` | 自定义 Characteristic               | **通知/上报通道**：连接后开启通知，用于设备主动上报信息（日志里打印 “发现FFE1-…”）    | 字符串/字节流（设备定义）                             | 连接成功 + 发现服务后      |
| `0000FFE2-0000-1000-8000-00805F9B34FB` | 自定义 Characteristic               | **“断开是否报警”配置写入通道**：连接后立即把策略写给设备（true/false）         | `0x01`=开启、`0x00`=关闭                       | 发现服务后立即写；或用户改设置时写 |
| `00002A06-0000-1000-8000-00805F9B34FB` | 标准 Characteristic（Alert Level）   | **即时报警控制通道**：用来“开始报警 / 取消报警”（日志里明确写“防丢器要响了”并缓存为写入口） | `0x01`=开始、`0x00`=取消（有些设备也支持 `0x02` 更强烈级别） | 发现服务后、需要立即控制报警时   |
| `00002A19-0000-1000-8000-00805F9B34FB` | 标准 Characteristic（Battery Level） | **读取电量**：发现服务后主动读取一次电量（日志“读取电量信息”）                  | 0–100（百分比，常见为 1 字节）                       | 发现服务后读取；或定时读取     |

---

## 二、三条“写入指令”的作用与使用方法（核心）

你关心的 3 条指令对应 **2 个写入入口**：

* **即时报警**（开始/取消）写到 **2A06**
* **断开是否报警**写到 **FFE2**

### 1) 开始报警（Immediate Alert / Alert Level）

* **写入 UUID**：`00002A06-...`
* **语义**：让设备“立刻进入报警状态”（响/震/闪，取决于设备）
* **写入数据**：`0x01`
* **正确使用方法（步骤）**

  1. 必须已连接成功（不是“扫到设备”）
  2. 必须已完成服务发现，并且你已经拿到 2A06 对应的可写特征值
  3. 确认当前没有其他写入在进行（同一条连接通常一次只能进行一个 write）
  4. 发送写入：写入 1 字节 `0x01`
  5. 通过“写入回调”判定成功/失败（见下文回调）

### 2) 取消报警

* **写入 UUID**：`00002A06-...`
* **语义**：让设备“立刻停止报警”
* **写入数据**：`0x00`
* **使用方法**：与开始报警完全相同，仅把写入值换成 `0x00`

> 关键理解：**开始/取消报警是“即时控制”**，写完后设备立即响应。

---

### 3) 断开是否报警（Disconnect Alarm Policy）

* **写入 UUID**：`0000FFE2-...`
* **语义（结合你工程行为）**

  * 这是一个“策略开关”：**断开连接时是否触发报警逻辑**
  * 你的工程在发现 FFE2 后会立刻写一次，把本地设置同步给设备（如果没有该设备条目则写 `false`）
* **写入数据**

  * `true` → `0x01`
  * `false` → `0x00`
* **正确使用方法（步骤）**

  1. 连接成功 + 服务发现完成后再写（否则没有写入口）
  2. 建议在两种场景写：

     * **连接刚建立时**：把策略同步给设备（你工程就是这么做的）
     * **用户修改设置时**：立即写入更新设备端策略
  3. 同样要遵守“同一连接避免并发写”，写完等回调再发下一条

> 关键理解：**断开是否报警是“配置/策略”，不是“立刻响/不响”**。
> 你工程里本地也会用同一个开关决定断开时手机是否播放声音（断开回调里会检查该开关再决定是否播放）。

---

## 三、写入/读取/通知的结果回调（你在别处复用最需要的部分）

### A) 写入结果回调（最重要）

当你对 2A06 或 FFE2 发起写入后，最终结果要看：

* **回调名称**：Characteristic Write 回调
* **你应该关注的点**

  1. **status/状态码**：是否成功（成功通常是 `GATT_SUCCESS`）
  2. **是哪一个 UUID 的写入结果**：用 characteristic 的 UUID 来区分是 2A06 还是 FFE2
  3. **失败处理**：失败时要考虑重试、延迟重发、或重新连接（不同设备差异很大）

> 经验规则：发起写入时“提交成功”不等于“设备写入成功”，**必须以回调 status 为准**。

---

### B) 通知上报回调（FFE1）

你在服务发现里对 **FFE1** 做了“开启通知”的动作。开启后，设备主动上报会进入：

* **回调名称**：Characteristic Changed 回调（通知/指示）
* **如何使用**

  1. 收到回调时，通过 UUID 判断是 FFE1
  2. 解析其值（你工程里打印了字符串值，但实际解析取决于设备协议：可能是 ASCII、也可能是二进制帧）
  3. 用于刷新 UI/状态（比如设备事件、报警状态变化、距离/信号信息等）

> 注意：不同设备对“通知”要求不同，有些设备还需要写入 CCCD 描述符才能真正生效；你在别处复用时要考虑这一点。

---

### C) 读取回调（2A19 电量）

你工程发现 `2A19` 后会主动“读电量”。读完后会进入：

* **回调名称**：Characteristic Read 回调
* **如何使用**

  1. 通过 UUID 判断是 2A19
  2. 把数据解释成电量百分比（常见 0–100）
  3. 存到设备条目并刷新 UI（电量图标/百分比）

---

## 四、你在别处复用时的最小“正确用法”清单（无代码版）

1. **必须先连接成功，再服务发现成功**，然后才能写 2A06/FFE2。
2. **写入一次只发一条**，等到写入回调回来（成功/失败）再发下一条。
3. **用 UUID 区分行为**：

   * 2A06：即时报警控制（开始/取消）
   * FFE2：断开报警策略配置
   * FFE1：通知上报通道
   * 2A19：电量读取
   * FFE0：扫描过滤服务
4. 写入是否成功 **以回调 status 为准**，不要只看“提交成功”。

---


