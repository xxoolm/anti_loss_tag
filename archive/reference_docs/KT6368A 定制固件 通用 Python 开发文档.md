KT6368A 定制固件 通用 Python 开发文档

> 目标：把现有 Android/  版本里**有用的业务逻辑、判断条件、流程、架构**抽取出来，整理成可在 Python 侧复用的开发文档；**不包含任何具体代码**。

---

## 1. 业务目标与边界

### 1.1 业务目标

系统围绕“防丢器/钥匙扣”类 BLE 外设实现以下能力：

* **发现设备**：基于特定服务 UUID 扫描过滤并短时扫描。
* **连接与服务发现**：连接成功后立即做 GATT 服务发现并缓存关键特征值句柄。
* **即时报警控制**：让设备“立刻响/立刻停”。
* **断开报警策略**：同步“断开是否报警”的策略到设备端。
* **按钮事件上报**：设备按键触发通知上报，客户端解析后触发本地动作（如播放声音/弹窗）。
* **电量读取**：连接后读取电量并持久化。
* **RSSI 轮询**：连接后读取信号强度并持久化。
* **断线处理**：断开后自动重连 + 条件满足时触发本地报警（考虑 Wi-Fi 勿扰、勿扰时段）。

### 1.2 边界与约束（从   实现推断）

* 扫描前要求“定位/GPS、蓝牙开关”等条件满足，否则直接失败返回。
* 设备列表中存在“我的设备”概念：扫描时会清理非我的设备条目，仅保留“我的设备”。
* 设备数量存在上限（示例里限制到 8 个）。

---

## 2. BLE 协议要点（UUID / 通道语义）

> 下表为“语义层”总结，可直接用于 Python 项目做协议映射与能力声明。

| UUID                                 | 类型                               | 语义（系统使用方式）                                    | 数据语义                           |
| ------------------------------------ | -------------------------------- | --------------------------------------------- | ------------------------------ |
| 0000FFE0-0000-1000-8000-00805F9B34FB | Service                          | **扫描过滤服务**：扫描时用作 ScanFilter 的 serviceUuid 条件。 | 无                              |
| 0000FFE1-0000-1000-8000-00805F9B34FB | Characteristic                   | **通知/上报通道**：连接并发现服务后开启通知；按键等事件从此上报。           | 字节流；  侧至少判断首字节为 1 代表一次按键事件。 |
| 0000FFE2-0000-1000-8000-00805F9B34FB | Characteristic                   | **断开报警策略写入通道**：服务发现后立即写入开关值，同步本地设置到设备。        | 0x01=启用、0x00=关闭。               |
| 00002A06-0000-1000-8000-00805F9B34FB | 标准 Characteristic（Alert Level）   | **即时报警控制**：服务发现后缓存为可写入口；用于开始/停止报警。            | 0x01=开始、0x00=停止。               |
| 00002A19-0000-1000-8000-00805F9B34FB | 标准 Characteristic（Battery Level） | **电量读取**：服务发现后主动读取一次；读回 1 字节并保存。              | 0–100（常见为 1 字节）。               |

---

## 3. 参考实现的架构拆解（可映射到 Python）

### 3.1 组件划分（建议 Python 侧按此拆分）

1. **Device Registry（设备注册表/缓存层）**
   维护“MAC → 设备记录、连接对象、特征值引用、重连计数”等映射。  侧用多个 Map 分别保存这些结构。

2. **BLE Manager（BLE 扫描/连接/GATT 管理）**

   * 扫描：短时扫描 + serviceUuid 过滤 + 扫描前置条件检查。
   * 连接：按 MAC 连接，回调驱动后续流程。
   * 服务发现：遍历所有服务与特征并缓存关键 UUID 对应的特征引用。

3. **Policy Engine（策略层：断开报警、勿扰条件）**
   断开时是否触发本地报警，取决于：

   * 每设备“断开报警开关”
   * 全局 Wi-Fi 勿扰开关
   * 全局 勿扰时段开关/时间窗口
       断线回调中按此顺序判断并决定是否播放声音。

4. **Persistence（持久化层）**
   启动时从本地数据库加载设备列表，并初始化连接状态、按钮文案、重连计数等。

5. **Event Bus / UI Notifier（事件与通知）**

   * “连接/断开”触发弹窗显示/隐藏。
   * FFE1 通知触发“按键事件”。

6. **Optional: Remote Verify（可选远端校验/上报）**
   服务发现完成后收集设备广播信息、MAC、特征摘要、App 版本等，进行 HTTP 上报并异步处理结果。

---

## 4. 数据模型（Python 推荐字段集合）

> 以“单设备记录”为核心，建议最少包含：

* **标识**

  * `mac`：设备 MAC（主键）
  * `name`：展示名（可从广播/扫描名清洗得到）
* **归属与展示**

  * `is_mine`：是否“我的设备”（扫描清理逻辑依赖）
  * `ui_button_state`：按钮展示状态（连接/连接中/报警中等；  写成功回调会切换文案状态）
* **连接与告警**

  * `is_connected`：是否已连接（服务发现成功后设为 true；断线时设为 false）
  * `is_alarming`：当前是否处于“报警态/需要报警态”（断线后会置为 true；重连成功后置为 false）
  * `alarm_on_disconnect`：断开是否报警（设备级策略开关）
  * `ring_index`：铃声/提示音选择（持久化字段存在）
* **信号与电量**

  * `battery_level`：电量百分比（读到后保存）
  * `rssi`：信号强度（readRemoteRssi 回调保存）
* **时间与审计**

  * `last_seen`：最近扫描/通知时间（用于离线判定与 UI）
  * `last_disconnect_time`：最近断开时间（用于告警节流）
* **GATT 运行态（不建议持久化）**

  * `gatt_connection_ref`：连接对象引用（  缓存到 Map）
  * `char_alert_level_ref`（2A06）
  * `char_notify_ref`（FFE1）
  * `char_disconnect_policy_ref`（FFE2）

---

## 5. 核心流程（按状态机描述）

### 5.1 启动初始化

1. 初始化全局工具与用户设置。
2. 从本地 DB 加载所有已保存设备，建立 `mac → 设备记录` 映射，并将每个设备：

   * 置为未连接
   * 标记为“我的设备”
   * 初始化重连计数为 5（在当前片段中看到赋值与重置，但未完整看到消费逻辑）
3. 注册蓝牙状态广播监听（用于蓝牙开关变化）。

### 5.2 扫描发现（Discovery）

1. 检查蓝牙与定位相关前置条件，不满足直接失败返回。
2. 扫描前清理“非我的设备”条目，仅保留“我的设备”。
3. 以 `FFE0 serviceUuid` 作为扫描过滤条件，启动扫描；扫描 5 秒后停止。

### 5.3 发现回调（Device Found）

1. 将扫描到的 `BluetoothDevice` 存入 `mac → device` 映射。
2. 若该 MAC 已存在于设备记录中：

   * 当设备处于“可连接”的按钮状态时，若是“我的设备”，则发起连接，并更新 UI 状态。
3. 若该 MAC 不在记录中：

   * 若设备数已达到上限（8），忽略。
   * 否则创建临时设备记录（包含清洗后的名称、MAC、初始按钮文案、是否支持电量等），并刷新 UI。

### 5.4 连接与断开（Connection State）

**连接成功：**

1. 触发服务发现；关闭连接进度提示；标记为“我的设备”；持久化；关闭连接弹窗。

**断开连接：**

1. 关闭连接对象并触发自动重连（按 MAC 立即发起连接）。
2. 若断开前设备被认为“处于连接状态”，则：

   * 弹出断开提示弹窗
   * 更新按钮状态为“断开态”
   * 标记设备 `is_connected=false`
   * 标记 `is_alarming=true`
   * 记录当前位置（用于“丢失地点”一类功能）
3. 是否触发本地报警（播放声音）取决于多重策略：

   * 若设备级“断开报警”关闭，则不报警并结束。
   * 若全局启用“Wi-Fi 勿扰”，且当前在 Wi-Fi 环境，则不报警并结束。
   * 若处于全局“勿扰时段”，则不报警；否则播放声音。

### 5.5 服务发现（Services Discovered）

当服务发现成功：

1. 遍历全部服务与特征，构建“服务/特征/描述符”摘要字符串（用于日志与可选远端校验）。
2. 发现关键特征后执行动作：

   * **2A06**：缓存为“即时报警写入口”，并触发 RSSI 读取流程。
   * **FFE1**：开启通知（后续按键上报依赖）。
   * **FFE2**：缓存为“断开报警策略写入口”，并立即把本地开关同步到设备端；若没有设备条目则按关闭处理。
   * **2A19**：立即读取一次电量。
3. 服务发现完成后：更新 UI 按钮为“已连接态”，标记设备已连接、报警关闭，并停止本地播放音。

### 5.6 通知回调（FFE1）

1. 收到 FFE1 通知后记录字节数组；当首字节为 1 时，视为“按键事件”，触发本地逻辑（例如播放音/弹窗/查找手机）。

### 5.7 写入回调（2A06 / FFE2）

* 写入成功后会触发“按钮状态切换”（体现为 UI 文案在两态间切换）。
* 经验约束：同一连接上建议避免并发写入；按“发一条、等回调、再发下一条”的顺序组织。

### 5.8 RSSI 回调

* 读取到 RSSI 后写入设备记录并持久化。

---

## 6. Python 侧落地建议（工程化要点）

### 6.1 并发模型

* BLE/GATT 操作天然是“回调/异步驱动”，且写入通常需要串行化。建议在 Python 侧：

  * 为每个连接维护“单通道操作队列”或“互斥锁”，保证写入/读写顺序与回调一致。
  * 将“服务发现后缓存特征引用”的结果写入运行态缓存，供后续动作调用。

### 6.2 状态机与事件总线

建议抽象为以下状态（每设备独立）：

* `DISCOVERED`（已发现）
* `CONNECTING`
* `CONNECTED`（含“服务发现完成”子状态）
* `DISCONNECTED`
* `ALARMING_LOCAL`（本地在响）
* `ALARMING_DEVICE`（设备在响）

并通过事件驱动联动 UI/上层业务：

* `on_device_found`
* `on_connected`
* `on_services_ready`
* `on_disconnected`
* `on_button_event`
* `on_battery_updated`
* `on_rssi_updated`

### 6.3 策略层复刻（断开报警）

Python 侧应保留与   侧一致的判断顺序与短路逻辑：

1. 设备级开关 `alarm_on_disconnect` 关闭则直接结束。
2. 全局 Wi-Fi 勿扰开启且当前 Wi-Fi 环境则结束。
3. 若处于勿扰时段则结束，否则执行本地报警（播放声音/推送通知等）。

### 6.4 扫描策略

* 扫描采用“短时窗口”（示例 5 秒），并基于 `FFE0` 过滤以减少噪声。
* 扫描前清理“非我的设备”，避免 UI 被临时设备污染。

### 6.5 关键健壮性点

* **特征不存在**：写入前必须确保已完成服务发现并已缓存对应特征引用，否则直接拒绝操作。
* **通知开启差异**：部分设备除“启用 notification”外还需要写 CCCD 描述符；应将其作为兼容性选项。
* **重复 UUID / 多特征同 UUID**：若出现同 UUID 多特征，需在 Python 侧引入“按 handle/instance 选择”的机制（你后续日志里遇到的现象属于这一类）。

---

## 7. 对外 API 设计（无代码、仅接口语义）

建议 Python 项目对外暴露以下能力（以 mac 为索引）：

* 设备管理

  * 添加/移除设备（移除时应断开连接并清理运行态缓存）。
  * 获取设备列表、获取单设备状态快照
* BLE 生命周期

  * 开始扫描 / 停止扫描（短时扫描策略）
  * 连接 / 断开 / 重连（断开自动重连与计数限制可选）
* GATT 操作

  * 开始报警（写 2A06=0x01）
  * 停止报警（写 2A06=0x00）
  * 设置断开报警策略（写 FFE2=0x01/0x00；连接建立后应自动同步一次）
  * 读取电量（读 2A19）
  * 读取 RSSI（连接后周期性调用）
* 事件订阅

  * 订阅按键事件（FFE1 通知）
  * 订阅连接状态、电量、RSSI、报警状态变化

---

## 8. 可选：远端校验/上报（如果你需要复刻）

* 时机：服务发现成功、遍历完服务与特征后。
* 内容：设备名、广播信息、MAC、特征摘要、App 版本等；请求为异步发送。
* 建议：Python 侧将该功能做成可插拔模块，默认关闭，并明确隐私告知。

---

。
