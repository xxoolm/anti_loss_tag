# BLE 防丢标签集成 - 完整技术参考文档

**版本**: v1.0.0  
**最后更新**: 2025-02-06  
**适用范围**: Home Assistant 自定义集成、Python开发、硬件设计

---

## 目录

1. [项目概述](#1-项目概述)
2. [用户文档](#2-用户文档)
3. [BLE协议技术规范](#3-ble协议技术规范)
4. [代码审查与改进建议](#4-代码审查与改进建议)
5. [开发规范与最佳实践](#5-开发规范与最佳实践)
6. [KT6368A芯片技术资料](#6-kt6368a芯片技术资料)
7. [架构设计与实现细节](#7-架构设计与实现细节)
8. [故障排除与调试](#8-故障排除与调试)

---

## 1. 项目概述

### 1.1 项目简介

一个用于 Home Assistant 的 BLE 防丢标签自定义集成，支持远程控制、电量监控和按钮事件触发。

### 1.2 核心功能

- **双向连接**: 主动连接和保持连接模式
- **实时监控**: RSSI 信号强度、连接状态、电池电量
- **远程控制**: 铃声开关、防丢开关
- **按钮事件**: 捕捉标签按钮点击事件（单击、双击、长按）
- **多设备支持**: 并发连接多个 BLE 标签
- **配置灵活**: 丰富的配置选项，可自定义轮询间隔、距离阈值等
- **智能重连**: 指数退避策略，避免连接风暴

### 1.3 支持的设备

| 服务 UUID | 说明 |
|-----------|------|
| `0000ffe0-0000-1000-8000-00805f9b34fb` | 主服务（扫描过滤用） |
| `0000ffe1-0000-1000-8000-00805f9b34fb` | 通知特征 |
| `0000ffe2-0000-1000-8000-00805f9b34fb` | 断开报警策略写入 |
| `00002a06-0000-1000-8000-00805f9b34fb` | 即时报警控制（Alert Level） |
| `00002a19-0000-1000-8000-00805f9b34fb` | 电量特征（Battery Level） |
| `00001802-0000-1000-8000-00805f9b34fb` | 即时报警服务 |

### 1.4 兼容设备

市面上大多数基于 nRF51/nRF52 芯片的 BLE 防丢标签，特别是使用 KT6368A 芯片的设备。

### 1.5 项目结构

```
anti_loss_tag/
├── custom_components/anti_loss_tag/  # 当前活跃代码
│   ├── __init__.py                    # 集成入口
│   ├── manifest.json                  # 集成清单
│   ├── const.py                       # 常量定义
│   ├── config_flow.py                 # 配置流程
│   ├── device.py                      # 设备管理（709行）
│   ├── connection_manager.py          # 连接管理器
│   ├── sensor.py                      # 传感器实体
│   ├── binary_sensor.py               # 二进制传感器实体
│   └── button.py                      # 按钮实体
├── archive/                           # 归档目录
│   ├── old_versions/                  # v1/v2旧版本代码
│   ├── reference_docs/                # KT6368A芯片文档
│   └── temp_files/                    # 临时文件
├── CODE_REVIEW.md                     # 代码审查报告
├── AGENTS.md                          # 开发规范手册
├── README.md                          # 用户文档
├── uuid.md                            # UUID技术参考
└── TECHNICAL_REFERENCE.md             # 本文档
```

---

## 2. 用户文档

### 2.1 安装方法

#### 通过 HACS 安装（推荐）

1. 在 HACS 中点击 "商店"
2. 搜索 "Anti Loss Tag"
3. 点击安装
4. 重启 Home Assistant

#### 手动安装

```bash
cp -r custom_components/anti_loss_tag ~/.homeassistant/custom_components/
```

### 2.2 配置流程

#### 添加设备

1. 在 Home Assistant 中进入 **设置** → **设备与服务**
2. 点击 **添加集成** → 搜索 "BLE 防丢标签"
3. 按照配对流程完成设备添加

#### 配置选项

| 选项 | 默认值 | 说明 | 范围 |
|------|--------|------|------|
| 维持连接 | 开启 | 是否保持与设备的持续连接 | 开/关 |
| 电量轮询间隔 | 60 分钟 | 电量读取间隔 | 5-10080 分钟 |
| RSSI 轮询间隔 | 5 分钟 | 信号强度读取间隔 | 1-60 分钟 |
| RSSI 阈值 | -80 dBm | 触发"远离"告警的信号强度阈值 | -100 to -50 dBm |
| 超时阈值 | 30 秒 | 连接超时时间 | 5-120 秒 |

### 2.3 实体说明

#### 传感器 (Sensor)

- **{设备名} 电量**: 设备电池电量（百分比）
- **{设备名} 信号强度**: RSSI 信号强度（dBm）
- **{设备名} 最后错误**: 最后一次错误信息（如有）

#### 二进制传感器 (Binary Sensor)

- **{设备名} 连接状态**: 设备是否已连接
- **{设备名} 可用状态**: 设备是否可用（最近被发现）
- **{设备名} 远离告警**: 设备信号弱于阈值
- **{设备名} 防丢状态**: 防丢功能是否启用

#### 按钮 (Button)

- **{设备名} 铃声开关**: 切换设备铃声
- **{设备名} 防丢开关**: 切换防丢功能

#### 事件 (Event)

- **{设备名} 按钮事件**: 捕捉设备按钮事件
  - `single_click`: 单击
  - `double_click`: 双击
  - `long_press`: 长按

### 2.4 自动化示例

#### 设备远离时发送通知

```yaml
automation:
  - alias: "标签远离提醒"
    trigger:
      - platform: state
        entity_id: binary_sensor.my_tag_far_away
        to: "on"
    action:
      - service: notify.mobile_app_my_phone
        data:
          title: "防丢提醒"
          message: "标签 '我的钥匙' 已远离！"
```

#### 双击按钮触发场景

```yaml
automation:
  - alias: "双击标签打开客厅灯"
    trigger:
      - platform: event
        event_type: anti_loss_tag_button_event
        event_data:
          device_id: "AA:BB:CC:DD:EE:FF"
          click_type: double_click
    action:
      - service: light.turn_on
        target:
          entity_id: light.living_room
```

#### 电量低时提醒

```yaml
automation:
  - alias: "标签电量低提醒"
    trigger:
      - platform: numeric_state
        entity_id: sensor.my_tag_battery
        below: 20
    action:
      - service: notify.mobile_app_my_phone
        data:
          title: "标签电量低"
          message: "标签 '我的钥匙' 电量仅剩 20%，请及时充电！"
```

### 2.5 故障排除

#### 设备无法连接

1. 确认设备蓝牙已开启且在范围内
2. 检查 Home Assistant 的蓝牙适配器权限
3. 尝试重启 Home Assistant
4. 查看日志：**设置** → **系统** → **日志**

#### 连接频繁断开

1. 增加 **超时阈值** 配置
2. 确认设备电量充足
3. 减少同时连接的 BLE 设备数量

#### 电量/信号不更新

1. 检查 **维持连接** 选项是否开启
2. 调整 **轮询间隔** 设置
3. 确认设备支持相应的 BLE 特征

---

## 3. BLE协议技术规范

### 3.1 UUID 总表

| UUID | 类型 | 作用 | 典型数据 | 何时用 |
|------|------|------|----------|--------|
| `0000FFE0-0000-1000-8000-00805F9B34FB` | Service | **扫描过滤用的服务 UUID** | 无（扫描过滤不读写数据） | 扫描阶段 |
| `0000FFE1-0000-1000-8000-00805F9B34FB` | Characteristic | **通知/上报通道** | 字节流（设备定义） | 连接成功 + 发现服务后 |
| `0000FFE2-0000-1000-8000-00805F9B34FB` | Characteristic | **"断开是否报警"配置写入通道** | `0x01`=开启、`0x00`=关闭 | 发现服务后立即写；或用户改设置时写 |
| `00002A06-0000-1000-8000-00805F9B34FB` | Standard Characteristic | **即时报警控制通道** | `0x01`=开始、`0x00`=取消 | 发现服务后、需要立即控制报警时 |
| `00002A19-0000-1000-8000-00805F9B34FB` | Standard Characteristic | **读取电量** | 0–100（百分比，1字节） | 发现服务后读取；或定时读取 |

### 3.2 三条写入指令的作用与使用方法

#### 1) 开始报警（Immediate Alert / Alert Level）

- **写入 UUID**: `00002A06-...`
- **语义**: 让设备"立刻进入报警状态"（响/震/闪）
- **写入数据**: `0x01`
- **正确使用方法**:
  1. 必须已连接成功
  2. 必须已完成服务发现，并且已经拿到 2A06 对应的可写特征值
  3. 确认当前没有其他写入在进行
  4. 发送写入：写入 1 字节 `0x01`
  5. 通过"写入回调"判定成功/失败

#### 2) 取消报警

- **写入 UUID**: `00002A06-...`
- **语义**: 让设备"立刻停止报警"
- **写入数据**: `0x00`
- **使用方法**: 与开始报警完全相同，仅把写入值换成 `0x00`

> 关键理解：**开始/取消报警是"即时控制"**，写完后设备立即响应。

#### 3) 断开是否报警（Disconnect Alarm Policy）

- **写入 UUID**: `0000FFE2-...`
- **语义**: 这是一个"策略开关"：**断开连接时是否触发报警逻辑**
- **写入数据**:
  - `true` → `0x01`
  - `false` → `0x00`
- **正确使用方法**:
  1. 连接成功 + 服务发现完成后再写
  2. 建议在两种场景写：
     - **连接刚建立时**：把策略同步给设备
     - **用户修改设置时**：立即写入更新设备端策略
  3. 同样要遵守"同一连接避免并发写"

> 关键理解：**断开是否报警是"配置/策略"，不是"立刻响/不响"**。

### 3.3 写入/读取/通知的结果回调

#### A) 写入结果回调（最重要）

- **回调名称**: Characteristic Write 回调
- **应该关注的点**:
  1. **status/状态码**: 是否成功（成功通常是 `GATT_SUCCESS`）
  2. **是哪一个 UUID 的写入结果**: 用 characteristic 的 UUID 来区分
  3. **失败处理**: 失败时要考虑重试、延迟重发、或重新连接

> 经验规则：发起写入时"提交成功"不等于"设备写入成功"，**必须以回调 status 为准**。

#### B) 通知上报回调（FFE1）

- **回调名称**: Characteristic Changed 回调（通知/指示）
- **如何使用**:
  1. 收到回调时，通过 UUID 判断是 FFE1
  2. 解析其值（可能是 ASCII、也可能是二进制帧）
  3. 用于刷新 UI/状态（如设备事件、报警状态变化、距离/信号信息等）

> 注意：不同设备对"通知"要求不同，有些设备还需要写入 CCCD 描述符才能真正生效。

#### C) 读取回调（2A19 电量）

- **回调名称**: Characteristic Read 回调
- **如何使用**:
  1. 通过 UUID 判断是 2A19
  2. 把数据解释成电量百分比（常见 0–100）
  3. 存到设备条目并刷新 UI

### 3.4 最小"正确用法"清单

1. **必须先连接成功，再服务发现成功**，然后才能写 2A06/FFE2
2. **写入一次只发一条**，等到写入回调回来（成功/失败）再发下一条
3. **用 UUID 区分行为**:
   - 2A06：即时报警控制（开始/取消）
   - FFE2：断开报警策略配置
   - FFE1：通知上报通道
   - 2A19：电量读取
   - FFE0：扫描过滤服务
4. 写入是否成功 **以回调 status 为准**，不要只看"提交成功"

---

## 4. 代码审查与改进建议

### 4.1 问题汇总

本次审查发现了**23个问题**：

- **严重问题 (P0)**: 2个（必须立即修复）
- **重要问题 (P1)**: 8个（应尽快修复）
- **一般问题 (P2)**: 7个（建议修复）
- **优化建议 (P3)**: 6个（可延后处理）

### 4.2 严重问题 (P0)

#### 4.2.1 device.py第352-358行缩进错误

**问题描述**:
```python
# 第352-358行
if self._conn_mgr is not None and self._conn_slot_acquired:
    await self._conn_mgr.release()
    self._conn_slot_acquired = False
# ====== 结束 ======
    self._async_dispatch_update()  # 缩进错误！
    return
```

**影响**: 逻辑错误，导致 `self._async_dispatch_update()` 和 `return` 在条件块外执行

**修复**:
```python
if self._conn_mgr is not None and self._conn_slot_acquired:
    await self._conn_mgr.release()
    self._conn_slot_acquired = False
# ====== 结束 ======
if self._client is None:  # 应该在这里检查
    self._async_dispatch_update()
    return
```

#### 4.2.2 项目根目录存在混乱文件

**问题描述**:
项目根目录包含大量不应提交的文件：
- `anti_loss_tag_v1/` 和 `anti_loss_tag_v2/` 目录（旧版本代码）
- `BLE协议实现指南.md` - BLE标准协议解读和实现指导
- `KT6368A*.pdf` 和 `KT6368A*.md`（临时文档）
- `init_git.sh` 脚本（一次性脚本）

**影响**: 违反"禁止修改任何代码文件/目录结构"的约束，可能导致混淆

**建议**: 这些文件已在.gitignore中，但需要从Git历史中移除

### 4.3 重要问题 (P1)

#### 4.3.1 custom_components目录包含不应存在的文件

**问题描述**:
`custom_components/anti_loss_tag/` 目录下包含 `anti_loss_tag_optimized_v2.zip`（31KB压缩包）

**影响**: 违反Home Assistant集成规范，可能导致HACS验证失败

#### 4.3.2 缺失必要的本地化文件

**问题描述**:
缺少 `strings.json` 文件，导致配置流程界面可能显示为原始键名而非中文。

**建议**: 创建 `custom_components/anti_loss_tag/translations/zh-Hans.json`

#### 4.3.3 重复的import语句散落在函数内部

**问题描述**:
多个函数内部重复 `import time` 和 `import random`：
- `async_ensure_connected()` 方法第337行、366行、391行、425行
- `_async_battery_loop()` 方法第698行

**影响**: 违反PEP 8规范，影响代码可读性

**建议**: 将所有import语句移到文件顶部

#### 4.3.4 竞态条件：连接槽位可能泄漏

**问题描述**:
`async_ensure_connected()` 中获取槽位后，如果后续步骤失败，槽位可能未正确释放。

**示例场景**:
1. 第361-373行：成功获取槽位
2. 第376-404行：建立连接失败，但捕获异常后未释放槽位
3. 槽位永久泄漏，导致其他设备无法连接

**建议**: 使用 try-finally 确保槽位释放

#### 4.3.5 _gatt_lock可能导致死锁

**问题描述**:
如果：
1. `_connect_lock` 保护 `async_ensure_connected()`
2. `_gatt_lock` 保护 GATT操作
3. GATT操作中可能触发重连

可能出现锁相互等待的死锁。

**建议**: 明确锁的层次结构：永远先获取 `_connect_lock`，再获取 `_gatt_lock`

#### 4.3.6 manifest.json字段更新 已在 v1.0.0 修复

**问题描述（已解决）**:
本问题在代码审查时发现，已在 v1.0.0 版本中修复。

**原始问题**:
manifest.json 缺少 2025 年 Home Assistant 要求的 `config_flow` 和 `integration_type` 字段，且 `iot_class` 使用了 `local_polling` 而非更准确的 `local_push`。

**当前状态（v1.0.0）**:
```json
{
  "domain": "anti_loss_tag",
  "name": "BLE 防丢标签",
  "version": "1.0.0",
  "documentation": "https://github.com/xxoolm/anti_loss_tag",
  "issue_tracker": "https://github.com/xxoolm/anti_loss_tag/issues",
  "codeowners": ["@MMMM"],
  "requirements": ["bleak>=0.21.0", "bleak-retry-connector>=3.0.0"],
  "iot_class": "local_push",
  "config_flow": true,
  "integration_type": "device",
  "dependencies": ["bluetooth_adapters"],
  "bluetooth": [
    {
      "domain": "anti_loss_tag",
      "service_uuid": "0000ffe0-0000-1000-8000-00805f9b34fb",
      "connectable": true
    }
  ]
}
```

**修复说明**:
-  添加 `config_flow: true` - 符合2025年标准，表示使用配置流程
-  添加 `integration_type: "device"` - **必需字段**，表示提供单个设备支持（不是集线器）
-  更新 `iot_class: "local_push"` - 更准确反映设备主动推送按钮事件的特性
-  添加 `dependencies: ["bluetooth_adapters"]` - 符合BLE集成最佳实践
-  包含 bluetooth matcher - 正确配置BLE服务UUID过滤和可连接属性

**关于 iot_class 的选择**:
- `local_push` 表示设备通过 BLE 通知（FFE1）主动上报事件
- 虽然电量需要轮询，但核心功能（按钮事件）是推送模式
- 这比 `local_polling` 更准确地反映了实时交互特性

**状态**: 已在 v1.0.0 修复 

### 4.4 一般问题 (P2)

#### 4.4.1 device.py文件过长，职责过多

**问题描述**:
- `device.py` 包含709行代码
- 混合了连接管理、GATT操作、事件处理、配置读取等多个职责
- 违反单一职责原则

**建议重构**:
```
device/
├── __init__.py           # 导出AntiLossTagDevice
├── device.py             # 核心设备类（300行以内）
├── connection.py         # 连接管理逻辑
├── gatt_ops.py           # GATT读写操作
├── event_handlers.py     # 蓝牙事件处理
└── config_options.py     # 配置选项读取
```

#### 4.4.2 重复的连接失败处理逻辑

**问题描述**:
device.py中多次出现相同的退避逻辑：
- 第384-393行（连接失败）
- 第419-427行（服务发现失败）

**建议**: 提取为独立方法 `_handle_connection_failure()`

#### 4.4.3 缺少类型注解

**问题描述**:
部分方法的参数和返回值缺少类型注解：
- `_on_disconnect()` 第317行
- `_resolve_char_handle()` 内部辅助函数

### 4.5 优化建议 (P3)

#### 4.5.1 缺少单元测试

**问题描述**:
项目没有任何单元测试或集成测试。

**建议**: 添加测试目录结构：
```
tests/
├── __init__.py
├── conftest.py
├── test_device.py
├── test_connection_manager.py
└── test_config_flow.py
```

#### 4.5.2 battery_poll使用随机抖动，但范围固定

**问题描述**:
第699-700行：`jitter = random.randint(0, 30)` 固定为0-30秒

**建议**: 使抖动范围可配置

#### 4.5.3 可以考虑缓存服务发现结果

**问题描述**:
每次连接后都调用 `client.get_services()`，但BLE服务通常不会变化。

**建议**: 缓存服务发现结果

### 4.6 优点总结

- 使用了全局连接管理器避免连接风暴
- 实现了指数退避策略
- 处理了多特征同UUID的歧义问题
- 使用了asyncio.Lock保护共享状态
- 完整的类型注解（大部分）
- 中文注释清晰

**评分**: 7.5/10

---

## 5. 开发规范与最佳实践

### 5.1 代码风格规范

#### 5.1.1 导入顺序（严格遵循）

```python
from __future__ import annotations  # 第一行（所有文件必须有）

# 标准库
import asyncio
import logging
from collections.abc import Callable

# 第三方库
from homeassistant.config_entries import ConfigEntry
from homeassistant.core import HomeAssistant
from bleak.exc import BleakError

# 本地模块
from .const import DOMAIN, CONF_ADDRESS
from .device import AntiLossTagDevice
```

#### 5.1.2 类型注解（必须）

- **所有函数**必须有返回类型注解
- 使用 `|` 语法（PEP 604）表示可选类型：`int | None`
- 集合类型使用内置泛型：`list[str]`、`dict[str, int]`、`set[Callable[[], None]]`
- 回调函数类型：`Callable[[], None]`、`Callable[[ButtonEvent], None]`

```python
async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
    """函数必须有 docstring 和类型注解。"""
    pass

def _opt_int(self, key: str, default: int) -> int:
    """私有方法也需要类型注解。"""
    pass
```

#### 5.1.3 命名约定

- **类名**: PascalCase (例: `AntiLossTagDevice`, `OptionsFlowHandler`)
- **函数/方法**: snake_case (例: `async_setup_entry`, `_async_write_bytes`)
- **私有成员**: 前缀下划线 (例: `_client`, `_connected`, `_ensure_connect_task`)
- **常量**: UPPER_SNAKE_CASE (例: `DOMAIN`, `CONF_ADDRESS`, `UUID_NOTIFY_FFE1`)
- **属性**: 使用 `@property` 装饰器，无下划线前缀 (例: `available`, `connected`)

#### 5.1.4 异步编程规范

- **所有 Home Assistant 相关方法**必须是 `async def`
- **回调函数**使用 `@callback` 装饰器，不使用 `async def`
- **锁**: 使用 `asyncio.Lock` 保护共享状态，避免竞态条件
- **任务创建**: 使用 `hass.async_create_task()` 而非 `asyncio.create_task()`

```python
async def async_ensure_connected(self) -> None:
    """连接方法必须使用 async def。"""
    async with self._connect_lock:  # 使用锁保护
        # 连接逻辑
        pass

@callback
def _async_on_bluetooth_event(self, service_info, change) -> None:
    """回调函数使用 @callback，不能是 async。"""
    self._available = True
```

#### 5.1.5 错误处理

- **特定异常优先**: 捕获具体异常类型（`BleakError`, `BleakConnectionError`）而非裸 `Exception`
- **安全网**: 最外层可使用 `except Exception as err` 作为安全网，记录后返回
- **错误状态**: 使用 `self._last_error: str | None` 记录错误，供 UI 显示
- **日志**: 使用 `_LOGGER` 模块级常量，级别适当（debug/info/warning/error）

```python
try:
    await client.get_services()
except (BleakError, BleakNotFoundError) as err:
    self._last_error = f"连接失败: {err}"
    _LOGGER.error("Service discovery failed: %s", err)
except Exception as err:  # 安全网
    self._last_error = f"未知错误: {err}"
    _LOGGER.exception("Unexpected error")
```

#### 5.1.6 数据类使用

- **简单数据容器**: 使用 `@dataclass`（例: `ButtonEvent`）
- **有状态对象**: 使用普通类（例: `AntiLossTagDevice`, `BleConnectionManager`）

```python
@dataclass
class ButtonEvent:
    when: datetime
    raw: bytes
```

#### 5.1.7 UUID 管理

- **所有 BLE UUID**定义在 `const.py` 中
- **UUID 全小写**，即使标准是混合大小写
- **命名**: `UUID_<SERVICE>_<CHARACTERISTIC>` 或 `UUID_SERVICE_<HEX>`

```python
UUID_NOTIFY_FFE1 = "0000ffe1-0000-1000-8000-00805f9b34fb"
UUID_BATTERY_LEVEL_2A19 = "00002a19-0000-1000-8000-00805f9b34fb"
```

### 5.2 Home Assistant 集成特定规范

#### 5.2.1 平台设置

- **PLATFORMS**: 在 `__init__.py` 定义，使用 `Platform` 枚举
- **entity_id 命名**: `{device.address}_{entity_type}` (例: `AA:BB:CC:DD:EE:FF_battery`)
- **实体名称**: 使用中文，格式 `{device.name} {类型}` (例: `标签A 电量`)

#### 5.2.2 Config Flow

- **继承**: `config_entries.ConfigFlow`, domain=DOMAIN
- **步骤方法**: `async_step_bluetooth`, `async_step_user`, `async_step_confirm`
- **Options Flow**: 单步骤，所有选项在 `async_step_init` 中定义
- **Schema**: 使用 `voluptuous`, 设置合理的默认值和范围

```python
vol.Required(
    CONF_BATTERY_POLL_INTERVAL_MIN,
    default=opts.get(CONF_BATTERY_POLL_INTERVAL_MIN, DEFAULT_BATTERY_POLL_INTERVAL_MIN),
): vol.All(int, vol.Range(min=5, max=7 * 24 * 60)),
```

#### 5.2.3 设备信息

- **DeviceInfo**: 使用设备地址作为唯一标识符
- **制造商/型号**: 使用中文，例如 `manufacturer="未知"`, `model="BLE 防丢标签"`

```python
DeviceInfo(
    identifiers={(DOMAIN, self._dev.address)},
    name=self._dev.name,
    manufacturer="未知",
    model="BLE 防丢标签",
)
```

### 5.3 调试与日志

#### 5.3.1 日志级别

- **DEBUG**: 详细的 BLE 操作细节（GATT 句柄解析、通知处理）
- **INFO**: 重要的状态变化（连接成功、断开、配置更新）
- **WARNING**: 警告但不影响功能的异常（多个 UUID 特征匹配）
- **ERROR**: 操作失败但仍可恢复（连接失败、读取失败）

#### 5.3.2 错误追踪

- **最后错误**: 始终记录到 `self._last_error`，供实体 UI 显示
- **日志上下文**: 使用 `%s` 占位符，而非字符串拼接

```python
_LOGGER.error("Failed to read battery from %s: %s", self.address, err)
```

### 5.4 并发控制

#### 5.4.1 连接槽位管理

- **全局管理器**: `BleConnectionManager` 使用 `asyncio.Semaphore` 限制并发连接数
- **槽位获取**: 连接前 `acquire()`, 失败后必须 `release()`
- **退避策略**: 连接失败后指数退避（`2^n` 秒），避免连接风暴

```python
# 获取槽位
acq = await self._conn_mgr.acquire(timeout=20.0)
if not acq.acquired:
    # 退避
    backoff = min(30, (2 ** self._connect_fail_count))
    self._cooldown_until_ts = time.time() + backoff
    return

# 失败释放
if self._conn_mgr is not None and self._conn_slot_acquired:
    await self._conn_mgr.release()
    self._conn_slot_acquired = False
```

#### 5.4.2 锁的使用

- **连接锁**: `_connect_lock` 保护连接/断开操作
- **GATT 锁**: `_gatt_lock` 保护读写操作

### 5.5 常见任务模式

#### 5.5.1 添加新的传感器实体

1. 在 `sensor.py` 创建新类，继承 `_AntiLossTagSensorBase`
2. 设置类属性（`_attr_device_class`, `_attr_native_unit_of_measurement`）
3. 实现 `native_value` 属性
4. 在 `async_setup_entry` 中添加到 `async_add_entities`

#### 5.5.2 添加新的配置选项

1. 在 `const.py` 定义 `CONF_*` 和 `DEFAULT_*`
2. 在 `OptionsFlowHandler.async_step_init` 添加 schema
3. 在 `device.py` 添加 `@property` 方法读取选项
4. 在 `async_apply_entry_options` 中处理选项变更

#### 5.5.3 处理新的 BLE 特征

1. 在 `const.py` 添加 UUID 常量
2. 在 `device.py` 添加读写方法（参考 `async_read_battery`）
3. 使用 `_resolve_char_handle` 解决 UUID 冲突
4. 使用 `@property` 暴露读取结果

---

## 6. KT6368A芯片技术资料

### 6.1 芯片定位与适用场景

- **定位**: 低成本、极简外围的 **Bluetooth 双模数据芯片**（BLE + SPP），典型用法是**UART 透传 + AT 配置**
- **协议**: Bluetooth V5.x，支持 BR/EDR/BLE 双模
- **典型产品**: 串口蓝牙透传模块、低功耗小型外设、简单人机交互（按键/指示灯/蜂鸣器）等

> 重要：KT6368A 通常不是"给你裸写应用固件的通用 MCU"用法；绝大多数成品都是**运行厂商固件**，硬件侧以"配套固件功能"为设计前提。

### 6.2 供电与电源完整性

#### 6.2.1 供电范围与建议

- **推荐工作电压**: **3.3V**；工作范围常见为 **2.2V–3.4V**（与纽扣电池/单节锂电适配）
- **测试警告**: **不要超过 3.6V**，否则可能损坏芯片

#### 6.2.2 电流特性（用于电源预算/电池寿命估算）

- **启动瞬态电流**: 约 **26mA**（启动后约 1 秒降到 ~4mA）
- **低功耗模式**: 进入瞬态约 25mA（约 300ms），未连接低功耗维持可到 **几十 µA 级**（文档示例 20µA）

> 设计含纽扣电池/防丢器这类"长待机"产品时，电源与 IO 上拉/下拉必须按"低功耗模式 IO 高阻"的特性去做。

#### 6.2.3 去耦/储能建议

- **VBAT 就近放置**: **0.1µF + 1µF**（或更大）去耦；走线尽量短，回地路径低阻抗
- **瞬态负载**: 若蜂鸣器/LED 等瞬态负载较大，建议在 VBAT 侧再加 4.7–10µF 级储能电容

### 6.3 封装与引脚定义（Pinout）

KT6368A 为 **SOP-8** 封装。基础 pin 定义如下：

| 引脚 | 名称 | 功能 |
|------|------|------|
| Pin1 | VBAT / VDDIO | 电源 |
| Pin3 | VSS | GND |
| Pin4 | BT_RF / BT Antenna | 射频单端天线脚 |
| Pin5 | BTOSCI | 高频晶振输入 |
| Pin6 | BTOSCO | 高频晶振输出 |
| Pin2 | PB1 | GPIO/复用功能（常见用作状态/控制） |
| Pin7/Pin8 | USBDM/USBDP | 可复用为 GPIO/UART/USB 等（取决于固件/模式） |

> 你实测"1=VBAT、3=GND、4=天线、5/6=晶振、7=LED、8=按键、2=蜂鸣器/控制脚"的板型，在引脚资源上是完全成立的。

### 6.4 时钟（Crystal）设计

KT6368A 通常需要外接 **高频晶体**到 Pin5/Pin6（BTOSCI/BTOSCO）。

**硬件要点**：

1. **晶体靠近芯片**（Pin5/6 到晶体走线极短、对称、等长，周围不要走高噪声线）
2. **负载电容**: 按晶体规格书的 **CL** 选型（常见在 8–12pF 级，需结合 PCB 寄生）
3. **地参考**: 晶体回路地参考要干净：负载电容回地就近打地过孔，避免与蜂鸣器/LED 回流共享长地线

### 6.5 射频与天线（RF）

#### 6.5.1 BT_RF（Pin4）与天线连接模式

- datasheet 直接给出 **BT_RF / BT Antenna** 单端输出脚
- 天线匹配位常见使用 **2.7pF**，但"实作也常用 0Ω 代替"；量产建议保留可调位置

#### 6.5.2 推荐 RF 布局要点（强约束）

1. **Pin4 到天线馈点的走线尽量短**、保持连续参考地、避免穿越分割地
2. **天线附近 keep-out**：天线区域下方/附近尽量不要铺地或放置金属/电池
3. **预留匹配网络焊盘**（哪怕初版 0Ω/不装），用于产测与不同壳体/电池/装配条件下调优

### 6.6 IO、电平与低功耗注意事项

#### 6.6.1 IO 复用与外设连接

- PB1（Pin2）与 Pin7/Pin8 在不同固件/模式下可承担：GPIO、串口、USB、状态指示等功能
- 你这种"蜂鸣器+LED+按键"的组合，常见实现是：
  - **蜂鸣器**: 用 PB1 输出 PWM/方波，或 PB1 驱动外置三极管/MOS（更稳，电流也可控）
  - **LED**: 直接 IO + 限流电阻（建议 1–5mA 级），或 IO 驱动晶体管
  - **按键**: IO 输入 + 上拉（内部/外部）；去抖可软件或 RC

#### 6.6.2 低功耗模式下 IO 状态（非常关键）

AT 文档明确写到：进入低功耗后 **"所有 IO 口为高阻态"**，并建议必要时给 Pin2/7/8 做上拉以判定 IO 状态。

**对硬件的直接要求**：

- **不要让关键控制对象依赖"IO 默认电平"**（因为低功耗会高阻漂移）
- 蜂鸣器/LED/外部开关管的栅极/基极建议加**硬件上拉/下拉**，确保低功耗时处于"确定的安全态"（例如蜂鸣器默认关断）

### 6.7 串口与调试/量产接口（UART / Boot Info）

#### 6.7.1 UART（AT 配置入口）

- AT Command 文档给出大量配置项（名称、地址、低功耗、参数存储等）；默认 UART 波特率在多份文档中出现 **115200**

**硬件建议**：

- 预留 UART 测试点（TX/RX/GND/VBAT），用于产测写参数、老化测试、问题定位
- 串口电平按 VBAT/VDDIO（通常 3.3V 系）
- 若产品使用低功耗（CL）模式，注意：文档描述低功耗下 AT 有效窗口与连接状态有关

#### 6.7.2 生产一致性（地址/参数写入）

AT 文档提到 **BLE 地址与 SPP 地址的关系**（SPP 地址由 BLE 地址高字节 +1 推导），因此量产通常只需要写 BLE 地址。

### 6.8 固件升级/下载与"USBDP/USBDM"脚的硬件策略

多份资料显示 Pin7/Pin8 虽标为 USBDM/USBDP，但在不同场景会被用作**下载/升级**或复用为 IO/UART。

**硬件建议（面向可维护性）**：

1. **强烈建议预留 Pin7/Pin8 的测试点/焊盘**（即使当前用作 LED/按键，也要能在产测夹具上接入）
2. 若 Pin7/8 外接 LED/按键，建议通过电阻/可断开设计，确保升级/调试时不被外部电路强拉电平或注入噪声
3. 产线若需要固件升级（而不是仅写 AT 参数），应按厂商/方案提供的下载工具与流程设计夹具

### 6.9 参考硬件框图（建议最小系统）

#### 6.9.1 最小系统（BLE/SPP 透传）

- **VBAT**: 2.2–3.4V
- **去耦**: 0.1µF + 1µF（就近）
- **晶体**: 连接 Pin5/6，配负载电容
- **天线**: Pin4 → 匹配预留（0Ω/2.7pF 位置）→ PCB 天线
- **UART**: TX/RX 测试点用于 AT 配置
- **IO**: PB1/Pin7/Pin8 用于 LED/按键/蜂鸣器（根据固件复用）

#### 6.9.2 纽扣电池防丢/蜂鸣器版本（你当前板型）

- **蜂鸣器建议**: IO → 驱动管 → 蜂鸣器（减少 IO 直驱电流压力、改善波形与响度一致性）
- **LED**: IO → 限流电阻 → LED
- **按键**: IO 输入 + 上拉（外部 100k 级可以降漏电；是否需要取决于固件的上拉与低功耗策略）

### 6.10 产测与验证清单（硬件侧）

1. **供电边界**: 2.2–3.4V（不要 >3.6V）
2. **晶体起振/频偏**: 上电广播稳定，连接不掉线；异常时优先排查晶体布局、负载电容
3. **RF 性能**: 不同装配状态（装电池/装外壳/手持）RSSI 与距离一致性；必要时通过匹配位微调（2.7pF/0Ω替换）
4. **低功耗**: 验证 IO 高阻引起的误触发风险（蜂鸣器误响、LED 漏亮、按键漂移），用外部上拉/下拉修正
5. **AT 产线流程**: 默认波特率（常见 115200），AT 参数写入与保存、地址写入策略

---

## 7. 架构设计与实现细节

### 7.1 业务目标与边界

#### 7.1.1 业务目标

系统围绕"防丢器/钥匙扣"类 BLE 外设实现以下能力：

- **发现设备**: 基于特定服务 UUID 扫描过滤并短时扫描
- **连接与服务发现**: 连接成功后立即做 GATT 服务发现并缓存关键特征值句柄
- **即时报警控制**: 让设备"立刻响/立刻停"
- **断开报警策略**: 同步"断开是否报警"的策略到设备端
- **按钮事件上报**: 设备按键触发通知上报，客户端解析后触发本地动作
- **电量读取**: 连接后读取电量并持久化
- **RSSI 轮询**: 连接后读取信号强度并持久化
- **断线处理**: 断开后自动重连 + 条件满足时触发本地报警

#### 7.1.2 边界与约束

- 扫描前要求"定位/GPS、蓝牙开关"等条件满足，否则直接失败返回
- 设备列表中存在"我的设备"概念：扫描时会清理非我的设备条目
- 设备数量存在上限（示例里限制到 8 个）

### 7.2 组件划分（建议 Python 侧按此拆分）

#### 7.2.1 Device Registry（设备注册表/缓存层）

维护"MAC → 设备记录、连接对象、特征值引用、重连计数"等映射。

#### 7.2.2 BLE Manager（BLE 扫描/连接/GATT 管理）

- **扫描**: 短时扫描 + serviceUuid 过滤 + 扫描前置条件检查
- **连接**: 按 MAC 连接，回调驱动后续流程
- **服务发现**: 遍历所有服务与特征并缓存关键 UUID 对应的特征引用

#### 7.2.3 Policy Engine（策略层：断开报警、勿扰条件）

断开时是否触发本地报警，取决于：

- 每设备"断开报警开关"
- 全局 Wi-Fi 勿扰开关
- 全局勿扰时段开关/时间窗口

断线回调中按此顺序判断并决定是否播放声音。

#### 7.2.4 Persistence（持久化层）

启动时从本地数据库加载设备列表，并初始化连接状态、按钮文案、重连计数等。

#### 7.2.5 Event Bus / UI Notifier（事件与通知）

- "连接/断开"触发弹窗显示/隐藏
- FFE1 通知触发"按键事件"

#### 7.2.6 Optional: Remote Verify（可选远端校验/上报）

服务发现完成后收集设备广播信息、MAC、特征摘要、App 版本等，进行 HTTP 上报并异步处理结果。

### 7.3 数据模型（Python 推荐字段集合）

以"单设备记录"为核心，建议最少包含：

#### 7.3.1 标识

- `mac`: 设备 MAC（主键）
- `name`: 展示名（可从广播/扫描名清洗得到）

#### 7.3.2 归属与展示

- `is_mine`: 是否"我的设备"（扫描清理逻辑依赖）
- `ui_button_state`: 按钮展示状态（连接/连接中/报警中等）

#### 7.3.3 连接与告警

- `is_connected`: 是否已连接（服务发现成功后设为 true；断线时设为 false）
- `is_alarming`: 当前是否处于"报警态/需要报警态"
- `alarm_on_disconnect`: 断开是否报警（设备级策略开关）
- `ring_index`: 铃声/提示音选择（持久化字段存在）

#### 7.3.4 信号与电量

- `battery_level`: 电量百分比（读到后保存）
- `rssi`: 信号强度（readRemoteRsi 回调保存）

#### 7.3.5 时间与审计

- `last_seen`: 最近扫描/通知时间（用于离线判定与 UI）
- `last_disconnect_time`: 最近断开时间（用于告警节流）

#### 7.3.6 GATT 运行态（不建议持久化）

- `gatt_connection_ref`: 连接对象引用
- `char_alert_level_ref`（2A06）
- `char_notify_ref`（FFE1）
- `char_disconnect_policy_ref`（FFE2）

### 7.4 核心流程（按状态机描述）

#### 7.4.1 启动初始化

1. 初始化全局工具与用户设置
2. 从本地 DB 加载所有已保存设备，建立 `mac → 设备记录` 映射
3. 注册蓝牙状态广播监听（用于蓝牙开关变化）

#### 7.4.2 扫描发现（Discovery）

1. 检查蓝牙与定位相关前置条件，不满足直接失败返回
2. 扫描前清理"非我的设备"条目，仅保留"我的设备"
3. 以 `FFE0 serviceUuid` 作为扫描过滤条件，启动扫描；扫描 5 秒后停止

#### 7.4.3 发现回调（Device Found）

1. 将扫描到的 `BluetoothDevice` 存入 `mac → device` 映射
2. 若该 MAC 已存在于设备记录中：
   - 当设备处于"可连接"的按钮状态时，若是"我的设备"，则发起连接
3. 若该 MAC 不在记录中：
   - 若设备数已达到上限（8），忽略
   - 否则创建临时设备记录并刷新 UI

#### 7.4.4 连接与断开（Connection State）

**连接成功**：

1. 触发服务发现；关闭连接进度提示；标记为"我的设备"；持久化
2. 关闭连接弹窗

**断开连接**：

1. 关闭连接对象并触发自动重连（按 MAC 立即发起连接）
2. 若断开前设备被认为"处于连接状态"，则：
   - 弹出断开提示弹窗
   - 更新按钮状态为"断开态"
   - 标记设备 `is_connected=false`
   - 标记 `is_alarming=true`
   - 记录当前位置
3. 是否触发本地报警（播放声音）取决于多重策略：
   - 若设备级"断开报警"关闭，则不报警并结束
   - 若全局启用"Wi-Fi 勿扰"，且当前在 Wi-Fi 环境，则不报警并结束
   - 若处于全局"勿扰时段"，则不报警；否则播放声音

#### 7.4.5 服务发现（Services Discovered）

当服务发现成功：

1. 遍历全部服务与特征，构建"服务/特征/描述符"摘要字符串
2. 发现关键特征后执行动作：
   - **2A06**: 缓存为"即时报警写入口"，并触发 RSSI 读取流程
   - **FFE1**: 开启通知（后续按键上报依赖）
   - **FFE2**: 缓存为"断开报警策略写入口"，并立即把本地开关同步到设备端
   - **2A19**: 立即读取一次电量
3. 服务发现完成后：更新 UI 按钮为"已连接态"，标记设备已连接、报警关闭，并停止本地播放音

#### 7.4.6 通知回调（FFE1）

1. 收到 FFE1 通知后记录字节数组
2. 当首字节为 1 时，视为"按键事件"，触发本地逻辑

#### 7.4.7 写入回调（2A06 / FFE2）

- 写入成功后会触发"按钮状态切换"（体现为 UI 文案在两态间切换）
- 经验约束：同一连接上建议避免并发写入；按"发一条、等回调、再发下一条"的顺序组织

#### 7.4.8 RSSI 回调

- 读取到 RSSI 后写入设备记录并持久化

### 7.5 Python 侧落地建议（工程化要点）

#### 7.5.1 并发模型

- BLE/GATT 操作天然是"回调/异步驱动"，且写入通常需要串行化
- 建议在 Python 侧：
  - 为每个连接维护"单通道操作队列"或"互斥锁"，保证写入/读写顺序与回调一致
  - 将"服务发现后缓存特征引用"的结果写入运行态缓存，供后续动作调用

#### 7.5.2 状态机与事件总线

建议抽象为以下状态（每设备独立）：

- `DISCOVERED`（已发现）
- `CONNECTING`
- `CONNECTED`（含"服务发现完成"子状态）
- `DISCONNECTED`
- `ALARMING_LOCAL`（本地在响）
- `ALARMING_DEVICE`（设备在响）

并通过事件驱动联动 UI/上层业务：

- `on_device_found`
- `on_connected`
- `on_services_ready`
- `on_disconnected`
- `on_button_event`
- `on_battery_updated`
- `on_rssi_updated`

#### 7.5.3 策略层复刻（断开报警）

Python 侧应保留一致的判断顺序与短路逻辑：

1. 设备级开关 `alarm_on_disconnect` 关闭则直接结束
2. 全局 Wi-Fi 勿扰开启且当前 Wi-Fi 环境则结束
3. 若处于勿扰时段则结束，否则执行本地报警

#### 7.5.4 扫描策略

- 扫描采用"短时窗口"（示例 5 秒），并基于 `FFE0` 过滤以减少噪声
- 扫描前清理"非我的设备"，避免 UI 被临时设备污染

#### 7.5.5 关键健壮性点

- **特征不存在**: 写入前必须确保已完成服务发现并已缓存对应特征引用
- **通知开启差异**: 部分设备除"启用 notification"外还需要写 CCCD 描述符；应将其作为兼容性选项
- **重复 UUID / 多特征同 UUID**: 若出现同 UUID 多特征，需在 Python 侧引入"按 handle/instance 选择"的机制

### 7.6 对外 API 设计（无代码、仅接口语义）

建议 Python 项目对外暴露以下能力（以 mac 为索引）：

#### 7.6.1 设备管理

- 添加/移除设备（移除时应断开连接并清理运行态缓存）
- 获取设备列表、获取单设备状态快照

#### 7.6.2 BLE 生命周期

- 开始扫描 / 停止扫描（短时扫描策略）
- 连接 / 断开 / 重连（断开自动重连与计数限制可选）

#### 7.6.3 GATT 操作

- 开始报警（写 2A06=0x01）
- 停止报警（写 2A06=0x00）
- 设置断开报警策略（写 FFE2=0x01/0x00；连接建立后应自动同步一次）
- 读取电量（读 2A19）
- 读取 RSSI（连接后周期性调用）

#### 7.6.4 事件订阅

- 订阅按键事件（FFE1 通知）
- 订阅连接状态、电量、RSSI、报警状态变化

---

## 8. 故障排除与调试

### 8.1 常见问题

#### 8.1.1 设备无法连接

**症状**: 设备在列表中显示，但无法连接

**可能原因**:
1. 设备蓝牙未开启或不在范围内
2. Home Assistant 的蓝牙适配器权限不足
3. 设备已被其他设备连接
4. 设备电量不足

**解决方案**:
1. 确认设备蓝牙已开启且在范围内
2. 检查 Home Assistant 的蓝牙适配器权限
3. 尝试重启 Home Assistant
4. 查看日志：**设置** → **系统** → **日志**

#### 8.1.2 连接频繁断开

**症状**: 设备连接后很快断开

**可能原因**:
1. 设备电量不足
2. 信号干扰严重
3. 超时阈值设置过小
4. 同时连接的 BLE 设备过多

**解决方案**:
1. 增加 **超时阈值** 配置
2. 确认设备电量充足
3. 减少同时连接的 BLE 设备数量
4. 检查日志中的断开原因

#### 8.1.3 电量/信号不更新

**症状**: 传感器数值长时间不变

**可能原因**:
1. **维持连接** 选项未开启
2. 轮询间隔设置过大
3. 设备不支持相应的 BLE 特征
4. 连接已断开但未检测到

**解决方案**:
1. 检查 **维持连接** 选项是否开启
2. 调整 **轮询间隔** 设置
3. 确认设备支持相应的 BLE 特征
4. 检查连接状态

#### 8.1.4 按钮事件不触发

**症状**: 按下设备按钮无响应

**可能原因**:
1. FFE1 通知未开启
2. 按钮事件协议不匹配
3. 设备固件不支持按钮事件

**解决方案**:
1. 检查日志中是否有 FFE1 通知记录
2. 尝试不同的按钮操作（单击/双击/长按）
3. 确认设备固件支持按钮事件

### 8.2 调试技巧

#### 8.2.1 启用调试日志

在 Home Assistant 配置文件中添加：

```yaml
logger:
  default: info
  logs:
    custom_components.anti_loss_tag: debug
    bleak: debug
```

#### 8.2.2 查看 BLE 设备信息

使用 Home Assistant 的开发者工具：

1. 进入 **开发者工具** → **状态**
2. 搜索 `sensor.*_rssi` 和 `binary_sensor.*_connected`
3. 查看设备状态和最后错误信息

#### 8.2.3 手动触发连接

在 Home Assistant 服务中调用：

```yaml
service: anti_loss_tag.connect
data:
  device_id: "AA:BB:CC:DD:EE:FF"
```

#### 8.2.4 测试 BLE 特征

使用外部工具（如 nRF Connect）验证设备 BLE 特征：

1. 连接设备
2. 查看服务列表
3. 确认 FFE0、FFE1、FFE2、2A06、2A19 特征存在
4. 测试读写操作

### 8.3 性能优化

#### 8.3.1 减少轮询频率

如果电量/信号更新不频繁，可以增加轮询间隔：

- **电量轮询间隔**: 从 60 分钟增加到 120 分钟
- **RSSI 轮询间隔**: 从 5 分钟增加到 10 分钟

#### 8.3.2 禁用维持连接

如果不需要实时监控，可以关闭 **维持连接** 选项：

- 设备仅在需要时连接
- 节省蓝牙适配器资源
- 减少电量消耗

#### 8.3.3 调整并发连接数

修改 `connection_manager.py` 中的最大并发连接数：

```python
class BleConnectionManager:
    def __init__(self, max_connections: int = 3):  # 从默认值调整
```

### 8.4 日志分析

#### 8.4.1 连接成功日志

```
INFO: Successfully connected to AA:BB:CC:DD:EE:FF
DEBUG: Services discovered, found FFE1, FFE2, 2A06, 2A19
INFO: Battery level: 85%
INFO: RSSI: -60 dBm
```

#### 8.4.2 连接失败日志

```
ERROR: Failed to connect to AA:BB:CC:DD:EE:FF: Timeout
WARNING: Backing off for 8 seconds (attempt 3)
```

#### 8.4.3 特征写入日志

```
DEBUG: Writing to 2A06: 0x01 (start alarm)
DEBUG: Write callback: success
INFO: Alarm started successfully
```

#### 8.4.4 按钮事件日志

```
DEBUG: Notification on FFE1: [0x01]
INFO: Button event: single_click
```

### 8.5 高级故障排除

#### 8.5.1 GATT 错误

**症状**: GATT 操作失败，错误码 0xXX

**常见错误码**:
- `0x01`: Invalid Handle
- `0x02`: Read Not Permitted
- `0x03`: Write Not Permitted
- `0x0E`: Insufficient Encryption
- `0x13`: Insufficient Authentication

**解决方案**:
1. 确认特征句柄正确
2. 检查设备是否需要配对
3. 验证设备固件支持该操作

#### 8.5.2 连接槽位泄漏

**症状**: 新设备无法连接，日志显示"无可用槽位"

**解决方案**:
1. 重启 Home Assistant
2. 减少同时连接的设备数量
3. 检查代码中槽位释放逻辑

#### 8.5.3 内存泄漏

**症状**: Home Assistant 内存使用持续增长

**解决方案**:
1. 检查是否存在循环引用
2. 确保回调函数正确解除注册
3. 定期重启 Home Assistant

---

## 附录

### A. 依赖项

- **Home Assistant**: >= 2024.1.0
- **bleak**: >= 0.21.0
- **bleak-retry-connector**: >= 3.0.0
- **bluetooth_adapters**: (Home Assistant 内置)

### B. manifest.json 2025年要求

根据 Home Assistant 2025年官方开发文档，自定义集成的 manifest.json 必须满足以下要求：

#### B.1 必需字段

| 字段 | 类型 | 说明 | 本项目值 |
|------|------|------|----------|
| `domain` | string | 集成唯一标识符 | `anti_loss_tag` |
| `name` | string | 集成显示名称 | `BLE 防丢标签` |
| `version` | string | 版本号（SemVer/CalVer） | `1.0.0` |
| `codeowners` | list | GitHub维护者列表 | `["@MMMM"]` |
| `documentation` | string | 文档URL | `https://github.com/xxoolm/anti_loss_tag` |
| `integration_type` | string | **集成类型（2025新增必需）** | `device` |
| `iot_class` | string | IoT类别 | `local_push` |
| `requirements` | list | Python依赖 | 见下文 |

#### B.2 integration_type 值说明（2025新增）

| 值 | 说明 | 适用场景 |
|------|------|----------|
| `device` | 提供单个设备 | ESPHome、Z-Wave等 |
| `hub` | 提供集线器，有多个设备或服务 | Philips Hue、ZHA等 |
| `service` | 单个服务 | Google Calendar等 |
| `helper` | 帮助实体 | |
| `hardware` | 硬件集成 | RPi GPIO等 |
| `system` | 系统集成 | |
| `virtual` | 虚拟集成 | |

**本项目使用 `device`**，因为每个防丢标签是一个独立的BLE设备，不是集线器架构。

#### B.3 iot_class 值说明

| 值 | 说明 | 适用场景 |
|------|------|----------|
| `local_polling` | 直接通信，需轮询状态 | 传统物联网设备 |
| `local_push` | 直接通信，设备主动推送 | BLE通知、MQTT等 |
| `cloud_push` | 通过云推送 | 云服务集成 |
| `cloud_polling` | 通过云轮询 | |

**本项目使用 `local_push`**，理由：
- 设备通过 FFE1 特征主动推送按钮事件
- 虽然电量需要轮询，但主要功能（按钮事件）是推送模式
- 更准确地反映实时交互特性

#### B.4 Quality Scale（质量等级）

Home Assistant 2025要求新集成至少达到 **Bronze** 级别：

| 等级 | 要求 |
|------|------|
| **Bronze** | 基本功能可用，有文档 |
| **Silver** | 完整文档，配置流程，支持日志 |
| **Gold** | 完整测试，异常处理，性能优化 |
| **Platinum** | 最高标准，官方认可 |

**本项目当前状态**: Bronze → Silver
-  基本功能完整 
-  有完整文档 
-  配置流程完善 
-  支持日志 
- 需改进：补充单元测试、优化错误处理

#### B.5 Bluetooth集成特殊要求

```json
{
  "dependencies": ["bluetooth_adapters"],
  "requirements": [
    "bleak>=0.21.0",
    "bleak-retry-connector>=3.0.0"
  ],
  "bluetooth": [
    {
      "domain": "anti_loss_tag",
      "service_uuid": "0000ffe0-0000-1000-8000-00805f9b34fb",
      "connectable": true
    }
  ]
}
```

**关键点**：
- 必须声明 `dependencies: ["bluetooth_adapters"]`
- 使用 `bleak-retry-connector` 处理连接重试（2025推荐）
- bluetooth matcher 配置服务UUID和可连接属性

### C. 相关链接

### B. 相关链接

- **GitHub**: https://github.com/xxoolm/anti_loss_tag
- **问题反馈**: https://github.com/xxoolm/anti_loss_tag/issues
- **Home Assistant 文档**: https://www.home-assistant.io/docs/

### C. 许可证

MIT License

### D. 更新日志

#### v1.0.0 (2025-02-06)

- 初始版本
- 支持基本的连接、控制和监控功能
- 支持按钮事件和自动化

---

**文档结束**

*本文档整合了用户文档、技术规范、代码审查、开发规范、硬件资料等多方面内容，为 BLE 防丢标签集成的开发、使用和维护提供完整的技术参考。*
