# BLE 协议技术规范

> **KT6368A 蓝牙防丢标签 BLE 协议完整规范**

## 一、UUID 总表

| UUID                                 | 类型                               | 作用                                                         | 典型数据                            | 使用时机               |
| ------------------------------------ | ---------------------------------- | ------------------------------------------------------------ | ----------------------------------- | ---------------------- |
| `0000FFE0-0000-1000-8000-00805F9B34FB` | 自定义 Service（厂商私有）          | **扫描过滤服务**：只扫描广播里声明了该服务的设备             | 无（扫描过滤不读写数据）             | 扫描阶段               |
| `0000FFE1-0000-1000-8000-00805F9B34FB` | 自定义 Characteristic              | **通知上报通道**：连接后开启通知，设备主动上报信息（按钮事件、日志等） | 字节流（设备定义协议）              | 连接成功 + 发现服务后  |
| `0000FFE2-0000-1000-8000-00805F9B34FB` | 自定义 Characteristic              | **断开报警策略配置**：配置断开连接时是否触发报警             | `0x01`=开启、`0x00`=关闭            | 发现服务后立即写       |
| `00002A06-0000-1000-8000-00805F9B34FB` | 标准 Characteristic（Alert Level） | **即时报警控制**：控制设备立即开始/停止报警                 | `0x01`=开始、`0x00`=取消            | 需要立即控制报警时     |
| `00002A19-0000-1000-8000-00805F9B34FB` | 标准 Characteristic（Battery Level）| **电量读取**：读取设备电量百分比                            | 0–100（1字节）                      | 发现服务后读取/定时读取 |

## 二、核心写入指令

### 1) 即时报警控制（2A06）

**写入 UUID**：`00002A06-...`

**语义**：让设备"立刻进入报警状态"（响/震/闪）

**写入数据**：
- `0x01` = 开始报警
- `0x00` = 取消报警
- `0x02` = 高级别报警（部分设备支持）

**正确使用流程**：
1. 必须已连接成功
2. 必须已完成服务发现，拿到 2A06 特征值
3. 确认当前没有其他写入操作
4. 发送写入请求
5. **等待写入回调**，以 status 为准判断成功/失败

---

### 2) 断开报警策略配置（FFE2）

**写入 UUID**：`0000FFE2-...`

**语义**：配置"断开连接时是否触发报警"的策略开关

**写入数据**：
- `0x01`（true）= 开启断开报警
- `0x00`（false）= 关闭断开报警

**正确使用流程**：
1. 连接成功 + 服务发现完成
2. 在以下时机写入：
   - **连接刚建立时**：把本地设置同步给设备
   - **用户修改设置时**：立即更新设备端策略
3. 避免并发写入，等待回调后再发下一条

---

### 3) 电量读取（2A19）

**读取 UUID**：`00002A19-...`

**语义**：读取设备当前电量百分比

**读取流程**：
1. 连接成功 + 服务发现完成
2. 发起读取请求
3. **等待读取回调**，解析数据（0-100百分比）
4. 存储并更新UI

---

## 三、通知上报机制（FFE1）

**通知 UUID**：`0000FFE1-...`

**语义**：设备主动上报信息的通道（按钮事件、状态变化等）

**启用流程**：
1. 连接成功 + 服务发现完成
2. 找到 FFE1 特征值
3. **开启通知**（enable notification）
4. 设备主动上报时触发 **Characteristic Changed 回调**

**数据解析**：
- 通过 UUID 判断是 FFE1
- 解析字节流（设备特定协议）
- 常见用途：按钮事件（首字节为 1 表示按键）

**注意事项**：
- 不同设备对"开启通知"的要求不同
- 有些设备需要写入 CCCD 描述符才能生效
- 建议在服务发现后立即开启通知

---

## 四、BLE 通信最佳实践

### 1. 操作顺序

```
扫描（FFE0过滤）
  ↓
连接
  ↓
服务发现（缓存特征值）
  ↓
开启通知（FFE1）
  ↓
读取电量（2A19）
  ↓
配置策略（FFE2）
  ↓
准备就绪
```

### 2. 并发控制

- **同一连接避免并发写入**：一次只发一条，等待回调后再发下一条
- **以回调 status 为准**：提交成功≠写入成功，必须等待回调确认

### 3. 错误处理

| 错误类型        | 处理建议                          |
| --------------- | --------------------------------- |
| 连接失败        | 延迟重试，使用指数退避            |
| 服务发现失败    | 重新连接                          |
| 写入失败        | 重试 3 次，仍失败则重新连接       |
| 通知开启失败    | 检查设备是否支持，尝试写入 CCCD   |
| 特征值不存在    | 记录日志，标记设备不支持该功能    |

### 4. 性能优化

- **短时扫描**：扫描 5 秒后自动停止，节省电量
- **UUID 过滤**：扫描时使用 FFE0 过滤，减少无关设备
- **特征缓存**：服务发现后缓存特征值引用，避免重复查询
- **连接池管理**：维护 MAC→Client 的映射，避免重复连接

---

## 五、数据格式规范

### 电量数据（2A19）

- **长度**：1 字节
- **范围**：0-100（百分比）
- **示例**：`0x64` = 100%

### 按钮事件（FFE1 通知）

- **格式**：字节流
- **常见解析**：首字节为 1 表示一次按键事件
- **示例**：`[0x01, 0x02, 0x03, ...]`

### 策略配置（FFE2 写入）

- **长度**：1 字节
- **值**：`0x01` 或 `0x00`

### 即时报警（2A06 写入）

- **长度**：1 字节
- **值**：`0x00`、`0x01` 或 `0x02`

---

## 六、常见问题

**Q: 为什么写入后没有效果？**

A: 检查以下几点：
1. 是否等待了写入回调并确认 status 成功
2. 是否有并发写入冲突
3. 特征值是否正确（通过 UUID 验证）

---

**Q: 为什么收不到 FFE1 通知？**

A: 检查以下几点：
1. 是否成功开启了通知（检查回调 status）
2. 部分设备需要写入 CCCD 描述符
3. 确认设备固件支持该功能

---

**Q: 扫描为什么扫不到设备？**

A: 检查以下几点：
1. 是否使用了 FFE0 服务 UUID 过滤
2. 设备是否正在广播（有些设备有广播间隔）
3. 蓝牙权限是否已授予

---

## 七、参考资源

- **KT6368A 硬件文档**：`docs/reference/kt6368a-hardware.md`
- **KT6368A 固件文档**：`docs/reference/kt6368a-firmware.md`
- **架构设计**：`docs/technical/architecture.md`
- **故障排除**：`docs/user/troubleshooting.md`
